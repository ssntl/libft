!<arch>
ft_atoi.c/      0           0     0     644     1219      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:29:13 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:44:12 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_atoi(const char *str)
{
	int	i;
	int	sign;

	i = 0;
	sign = 1;
	while ((*str >= 9 && *str <= 13) || *str == 32)
		str++;
	if (*str == 43 || *str == 45)
	{
		if (*str == 45)
			sign *= -1;
		str++;
	}
	while (*str >= 48 && *str <= 57)
	{
		i = i * 10 + (*str - '0');
		str++;
	}
	return (i * sign);
}

ft_bzero.c/     0           0     0     644     1208      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:29:18 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:14:40 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	bzero(void *s, size_t len)
{
	ft_memset(s, 0, len);
}
/*
	void *s: A pointer to the memory area where zeroing will occur.
	0: The value to be set (in this case, 0 represents the null byte
	or zero-value byte).
	size_t len: The number of bytes to set to zero, starting from the address s.
*/
ft_calloc.c/    0           0     0     644     1104      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:29:29 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 19:21:18 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*buffer;

	buffer = (void *)malloc(nmemb * size);
	if (buffer == NULL)
		return (NULL);
	ft_bzero(buffer, nmemb * size);
	return (buffer);
}
ft_isalnum.c/   0           0     0     644     980       `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:29:33 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 14:44:24 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalnum(int c)
{
	return (ft_isalpha(c) || ft_isdigit(c));
}
ft_isalpha.c/   0           0     0     644     1444      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/14 11:30:22 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 15:16:31 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
       isalpha()
              checks  for an alphabetic character; in the standard "C" locale,
              it is equivalent to (isupper(c) ||  islower(c)).   In  some  lo‐
              cales, there may be additional characters for which isalpha() is
              true—letters which are neither uppercase nor lowercase.
*/

#include "libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	else
		return (0);
}

/*
#include <stdio.h>

int main (void)
{
    printf("%d", ft_isalpha (97));
}
*/
ft_isascii.c/   0           0     0     644     968       `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:30:12 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 14:44:24 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isascii(int c)
{
	return (c >= 0 && c <= 127);
}
ft_isdigit.c/   0           0     0     644     997       `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/14 11:37:12 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:15:38 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c <= 57 && c >= 48)
		return (1);
	else
		return (0);
}

ft_isprint.c/   0           0     0     644     998       `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:30:37 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:15:37 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	else
		return (0);
}
ft_itoa.c/      0           0     0     644     1388      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:23:35 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 19:51:49 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	size(int i)
{
	int	j;

	j = 0;
	if (i == 0)
		return (1);
	while (i)
	{
		i /= 10;
		i++;
	}
	return (j);
}

char	*ft_itoa(int n)
{
	char	*str;
	size_t	i;
	long	j;

	j = n;
	i = size(n);
	if (n < 0)
		j *= -1;
	str = (char *)malloc(i + 1);
	if (!str)
		return (NULL);
	*(str + i--) = '\0';
	while (j > 0)
	{
		*(str + i--) = j % 10 + '0';
		j /= 10;
	}
	if (i == 0 && str[1] == '\0')
		*(str + i) = '0';
	else if (i == 0 && str[1])
		*(str + i) = '-';
	return (str);
}
ft_memchr.c/    0           0     0     644     2340      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:25:26 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 17:20:12 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
DESCRIPTION
The memchr() function scans the initial n bytes of the memory area pointed to by
s for the first instance of c.  Both c and the bytes of the memory area  pointed
to by s are interpreted as unsigned char.

The  memrchr()  function  is like the memchr() function, except that it searches
backward from the end of the n bytes pointed to by s instead of forward from the
beginning.
The  rawmemchr() function is similar to memchr(): it assumes (i.e., the program‐
mer knows for certain) that an instance of c lies somewhere in the  memory  area
starting  at  the  location pointed to by s, and so performs an optimized search
for c (i.e., no use of a count argument to limit the range of the  search).   If
an  instance  of  c  is not found, the results are unpredictable.  The following
call is a fast means of locating a string's terminating null byte:

char *p = rawmemchr(s, '\0');

RETURN VALUE
The memchr() and memrchr() functions return a pointer to the  matching  byte  or
NULL if the character does not occur in the given memory area.

The  rawmemchr()  function  returns  a  pointer  to the matching byte, if one is
found.  If no matching byte is found, the result is unspecified.
*/
#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	char	*str;
	size_t	i;

	i = 0;
	str = (char *)s;
	while (i < n)
	{
		if ((unsigned char)str[i] == (unsigned char)c)
			return ((char *)s + i);
		i++;
	}
	return (NULL);
}
ft_memcmp.c/    0           0     0     644     1764      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:30:47 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 17:42:49 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
DESCRIPTION
The  memcmp()  function compares the first n bytes (each interpreted as unsigned
char) of the memory areas s1 and s2.

RETURN VALUE
The memcmp() function returns an integer less than, equal to,  or  greater  than
zero  if  the  first  n  bytes of s1 is found, respectively, to be less than, to
match, or be greater than the first n bytes of s2.

For a nonzero return value, the sign is determined by the sign of the difference
between the first pair of bytes (interpreted as unsigned char) that differ in s1
and s2.

If n is zero, the return value is zero.
*/
#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	char		*str1;
	char		*str2;
	size_t		i;

	i = 0;
	str1 = (char *)s1;
	str2 = (char *)s2;
	while (i < n)
	{
		if (str1[i] != str2[i])
			return ((unsigned char)str1[i] - (unsigned char)str2[i]);
		i++;
	}
	return (0);
}
ft_memmove.c/   0           0     0     644     1483      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:30:53 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:42:05 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
	The  memmove() function copies n bytes from memory area src to memory
	area dest.
	The memory areas may overlap: copying takes place as though
	the bytes in src are
	first  copied  into a temporary array that does not overlap src or dest, and the
	`bytes are then copied from the temporary array to dest.
*/
#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	char	*s;
	char	*d;
	size_t	i;

	s = (char *)src;
	d = (char *)dest;
	i = 0;
	if (d > s)
		while (n-- > 0)
			d[n] = s[n];
	else
	{
		while (i < n)
		{
			d[i] = s[i];
			i++;
		}
	}
	return (dest);
}

ft_memset.c/    0           0     0     644     1204      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:30:57 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 17:44:43 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
The  memset()  function  fills  the  first  n(len)  bytes of the memory area
       pointed to by s with the constant byte c.
*/
#include "libft.h"

void	*ft_memset(void *s, int c, size_t len)
{
	unsigned char	*ptr;

	ptr = (unsigned char *)s;
	while (len-- > 0)
		*(ptr++) = (unsigned char)c;
	return (s);
}
ft_putchar_fd.c/0           0     0     644     971       `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:24:21 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 19:53:39 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write (fd, &c, 1);
}

ft_putendl_fd.c/0           0     0     644     1024      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:24:58 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 19:56:45 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	if (s != NULL)
	{
		ft_putstr_fd(s, fd);
		ft_putchar_fd('\n', fd);
	}
}
ft_putnbr_fd.c/ 0           0     0     644     1161      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:25:20 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 20:21:33 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	unsigned int	i;

	i = 0;
	if (n < 0)
	{
		ft_putchar_fd('-', fd);
		i = (unsigned int)(n * -1);
	}
	else
		i = (unsigned int)n;
	if (i >= 10)
		ft_putnbr_fd(i / 10, fd);
	ft_putchar_fd((char)(i % 10 + 48), fd);
}

ft_split.c/     0           0     0     644     2088      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:11:09 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/22 18:33:54 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
// count words or substrings
size_t	count_words(char const *s, char c)
{
	size_t	words;
	int		flag;

	words = 0;
	while (*s)
	{
		flag = 0;
		while (*s == c && *s)
			s++;
		while (*s != c && *s)
		{
			if (flag == 0)
			{
				words++;
				flag = 1;
			}
			s++;
		}
	}
	return (words);
}

int	safe_malloc(char **something, int pos, size_t buffer)
{
	int	i;

	i = 0;
	something[pos] = malloc(buffer);
	if (NULL == something[pos])
	{
		while (i < pos)
			free(something[i++]);
		free(something);
		return (1);
	}
	return (0);
}

int	fill(char **something, char const *s, char c)
{
	size_t	len;
	int		i;

	i = 0;
	while (*s)
	{
		len = 0;
		while (*s == c && *s)
			s++;
		while (*s != c && *s)
		{
			len++;
			s++;
		}
		if (len)
		{
			if (safe_malloc(something, i, len + 1))
				return (1);
			ft_strlcpy(something[i], s - len, len + 1);
		}
		i++;
	}
	return (0);
}

char	**ft_split(char const *s, char c)
{
	size_t	words;
	char	**something;

	words = count_words(s, c);
	something = malloc(sizeof(char *) * (words + 1));
	if ((NULL == s) || (NULL == something))
		return (NULL);
	something[words] = NULL;
	if (fill(something, s, c))
		return (NULL);
	return (something);
}
ft_strchr.c/    0           0     0     644     2035      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:00 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 17:24:32 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
DESCRIPTION
The strchr() function returns a pointer to the first occurrence of the character
c in the string s.

The strrchr() function returns a pointer to the last occurrence of the character
c in the string s.

The  strchrnul()  function  is like strchr() except that if c is not found in s,
then it returns a pointer to the null byte at the end of s, rather than NULL.

Here "character" means "byte"; these functions do not work with wide  or  multi‐
byte characters.

RETURN VALUE
The  strchr()  and strrchr() functions return a pointer to the matched character
or NULL if the character is not found.  The terminating null byte is  considered
part  of the string, so that if c is specified as '\0', these functions return a
pointer to the terminator.

The strchrnul() function returns a  pointer  to  the  matched  character,  or  a
pointer to the null byte at the end of s (i.e., s+strlen(s)) if the character is
not found.
*/

#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	while (*s)
	{
		if (*s == (unsigned char)c)
			return ((char *)s);
		s++;
	}
	if (*s == (unsigned char)c)
		return ((char *)s);
	return (0);
}

ft_strdup.c/    0           0     0     644     1545      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:03 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 19:18:03 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
DESCRIPTION
The  strdup() function returns a pointer to a new string which is a duplicate of
the string s.  Memory for the new string is obtained with malloc(3), and can  be
freed with free(3).
RETURN VALUE
On success, the strdup() function returns a pointer to  the  duplicated  string.
It returns NULL if insufficient memory was available, with errno set to indicate
the cause of the error.
*/

#include "libft.h"

char	*ft_strdup(const char *s)
{
	char	*str;
	size_t	i;

	i = 0;
	str = (char *)malloc(sizeof(char) * ft_strlen(s) + 1);
	if (str == NULL)
		return (NULL);
	while (s[i])
	{
		str[i] = s[i];
		i++;
	}
	str[i] = '\0';
	return (str);
}

ft_striteri.c/  0           0     0     644     1042      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:24:04 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 20:22:47 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	unsigned int	i;

	i = 0;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}
ft_strjoin.c/   0           0     0     644     1280      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:06 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 20:34:56 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	size_t	i;
	size_t	j;
	char	*str;

	i = 0;
	j = 0;
	if (!s1 || !s2)
		return (NULL);
	str = (char *)malloc(sizeof(char) * (ft_strlen(s1) + ft_strlen(s2) + 1));
	if (!str)
		return (NULL);
	while (s1[i] != '\0')
	{
		str[i] = s1[i];
		i++;
	}
	while (s2[j] != '\0')
	{
		str[i + j] = s2[j];
		j++;
	}
	return (str);
}
ft_strlcat.c/   0           0     0     644     3124      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:13 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 17:08:42 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
DESCRIPTION
The strlcpy() and strlcat() functions copy and concatenate strings respectively
They are designed to be safer, more consistent,
and less error prone replacements
for strncpy(3) and strncat(3).  Unlike those functions, strlcpy() and strlcat()
take the full size of the buffer (not just the length) and guarantee to
NUL-termi‐
nate the result (as long as size is larger than 0 or, in the case of strlcat(),
as long as there is at least one byte free in dst).
Note that a byte for the NUL
should be included in size.
Also note that strlcpy() and strlcat() only operate
on true “C” strings.
This means that for strlcpy() src must be NUL-terminated and
for strlcat() both src and dst must be NUL-terminated.
The strlcpy() function copies up to size - 1 characters from the NUL-terminated
string src to dst, NUL-terminating the result.
The strlcat() function appends the NUL-terminated string src to the end of dst.
It will append at most size - strlen(dst) - 1 bytes, NUL-terminating the result.

RETURN VALUES
The strlcpy() and strlcat() functions return the total length of the string they
tried to create.  For strlcpy() that means the length of src.  For strlcat() that
means the initial length of dst plus the length of src.  While this may seem
somewhat confusing, it was done to make truncation detection simple.
Note, however, that if strlcat() traverses size characters without finding a NUL,
the length of the string is considered to be size and the destination string will
not be NUL-terminated (since there was no space for the NUL).  This keeps
strlcat() from running off the end of a string.  In practice this should not hap‐
pen (as it means that either size is incorrect or that dst is not a proper “C”
string).
The check exists to prevent potential security problems in incorrect
code.
*/
#include "libft.h"

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t		altdst;
	size_t		altsrc;
	size_t		i;

	if (!size)
		return (ft_strlen(dst) + size);
	altsrc = ft_strlen(src);
	i = 0;
	while (dst[i] && i < size)
		i++;
	altdst = i;
	while (src[i - altdst] && i < size - 1)
	{
		dst[i] = src[i - altdst];
		i++;
	}
	if (altdst < size)
		dst[i] = '\0';
	return (altdst + altsrc);
}
ft_strlcpy.c/   0           0     0     644     3031      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:20 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/22 18:36:17 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
DESCRIPTION
The strlcpy() and strlcat() functions copy and concatenate strings respectively
They are designed to be safer, more consistent,
and less error prone replacements
for strncpy(3) and strncat(3).  Unlike those functions, strlcpy() and strlcat()
take the full size of the buffer (not just the length) and guarantee to
NUL-termi‐
nate the result (as long as size is larger than 0 or, in the case of strlcat(),
as long as there is at least one byte free in dst).
Note that a byte for the NUL
should be included in size.
Also note that strlcpy() and strlcat() only operate
on true “C” strings.
This means that for strlcpy() src must be NUL-terminated and
for strlcat() both src and dst must be NUL-terminated.
The strlcpy() function copies up to size - 1 characters from the NUL-terminated
string src to dst, NUL-terminating the result.
The strlcat() function appends the NUL-terminated string src to the end of dst.
It will append at most size - strlen(dst) - 1 bytes, NUL-terminating the result.

RETURN VALUES
The strlcpy() and strlcat() functions return the total length of the string they
tried to create.  For strlcpy() that means the length of src.  For strlcat() that
means the initial length of dst plus the length of src.  While this may seem
somewhat confusing, it was done to make truncation detection simple.
Note, however, that if strlcat() traverses size characters without finding a NUL,
the length of the string is considered to be size and the destination string will
not be NUL-terminated (since there was no space for the NUL).  This keeps
strlcat() from running off the end of a string.  In practice this should not hap‐
pen (as it means that either size is incorrect or that dst is not a proper “C”
string).
The check exists to prevent potential security problems in incorrect
code.
*/
#include "libft.h"

size_t	ft_strlcpy(char *dst, const char *src, size_t size)
{
	size_t	i;

	i = 0;
	if (size == 0)
	{
		while (src[i])
			i++;
		return (i);
	}
	while (i < size -1 && src[i] != '\0')
	{
		dst[i] = src[i];
		i++;
	}
	if (i < size)
		dst[i] = '\0';
	while (src[i] != '\0')
		i++;
	return (i);
}

ft_strlen.c/    0           0     0     644     1002      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:24 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:16:17 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlen(const char *s)
{
	size_t	i;

	i = 0;
	while (s[i])
		i++;
	return (i);
}
ft_strmapi.c/   0           0     0     644     1149      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:23:50 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 20:25:03 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	char			*str;
	unsigned int	i;

	i = 0;
	str = ft_strdup(s);
	if (!s || !f || !str)
		return (NULL);
	while (str[i])
	{
		str[i] = f(i, str[i]);
		i++;
	}
	return (str);
}

ft_strncmp.c/   0           0     0     644     1216      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:09:49 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:16:23 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* basically same as ft_strcmp but only comparing up to size_t n chars in s1*/
#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	if (n == 0)
		return (0);
	i = 0;
	while (s1[i] != '\0' && s1[i] == s2[i] && i < n - 1)
		i++;
	return ((unsigned char) s1[i] - (unsigned char)s2[i]);
}
ft_strnstr.c/   0           0     0     644     1789      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:36 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 17:42:14 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
DESCRIPTION
The strnstr() function locates the first occurrence of the null-terminated string
little in the string big, where not more than len characters are searched.  Char‐
acters that appear after a ‘\0’ character are not searched.  Since the strnstr()
function is a FreeBSD specific API, it should only be used when portability is
not a concern.

RETURN VALUES
If little is an empty string, big is returned; if little occurs nowhere in big,
NULL is returned; otherwise a pointer to the first character of the first occur‐
rence of little is returned.
*/

#include "libft.h"

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	while (i < len && big[i] != '\0')
	{
		j = 0;
		while (i + j < len && big[i + j] == little[j] && little[j] != '\0')
			j++;
		if (little[j] == '\0')
			return ((char *)big + i);
		i++;
	}
	return (NULL);
}

ft_strrchr.c/   0           0     0     644     1218      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:40 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 17:34:08 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
The strrchr() function returns a pointer to the last occurrence
 of the character c in the string s.
*/
#include "libft.h"

char	*ft_strrchr(const char *s, int c)
{
	int	i;

	i = ft_strlen(s);
	if (c == 0)
		return ((char *)s + i);
	while (i >= 0)
	{
		if (s[i] == c)
			return ((char *)s + i);
		i--;
	}
	return (NULL);
}
ft_strtrim.c/   0           0     0     644     1438      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:22:51 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 23:25:30 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strtrim(char const *s1, char const *set)
{
	int		start;
	int		end;
	char	*noset;

	start = 0;
	end = ft_strlen(s1) -1;
	if (s1 == NULL || set == NULL)
		return (NULL);
	if (!*s1)
		return (ft_strdup(s1));
	while (*(s1 + start) && ft_strchr(set, *(s1 + start)))
		++start;
	while (end >= 0 && ft_strchr(set, *(s1 + end)))
		--end;
	if (start > end)
		return (ft_strdup(""));
	noset = malloc((end - start) + 2);
	if (NULL == noset)
		return (NULL);
	ft_strlcpy(noset, s1 + start, (end - start) + 2);
	return (noset);
}
ft_substr.c/    0           0     0     644     1353      `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/21 19:21:53 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 19:36:04 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	unsigned int	i;
	char			*str;

	i = 0;
	if (start >= ft_strlen(s))
	{
		str = ft_calloc(1, sizeof(char));
		if (!str)
			return (NULL);
		return (str);
	}
	if (ft_strlen(s) - start < len)
		len = ft_strlen(s) - start;
	str = ft_calloc(sizeof(char), len + 1);
	if (!str)
		return (NULL);
	while (s[start + i] && i < len)
	{
		str[i] = s[start + i];
		i++;
	}
	return (str);
}

ft_tolower.c/   0           0     0     644     987       `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:45 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:16:32 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_tolower(int c)
{
	if (c >= 65 && c <= 90)
		c += 32;
	return (c);
}

ft_toupper.c/   0           0     0     644     988       `
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bsaager <bsaager@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/19 09:31:47 by bsaager           #+#    #+#             */
/*   Updated: 2023/12/21 16:16:34 by bsaager          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_toupper(int c)
{
	if (c >= 97 && c <= 122)
		c -= 32;
	return (c);
}
